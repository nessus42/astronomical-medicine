#!/usr/bin/env python2.5
# -*- Mode: Python; fill-column: 79; fill-prefix: "# " -*-

usage = "usage: %prog {input-2D-FITS-file} {output-3D-FITS-file}"

from sys import stdout, stderr
import sys

#------------------------------------------------------------------------------
# main()
#------------------------------------------------------------------------------

def main():

   parser = parseCommandLine()
   inputFilepath = parser.largs[0]
   outputFilepath = parser.largs[1]
   options = parser.values

   replacementImage = None
   if options.replacementImageFilepath:
      import Image
      replacementImage = (Image.open(options.replacementImageFilepath)
                          .transpose(Image.ROTATE_180))

      # Convert the image to black and white, either by extracting one of the
      # color components, or calculating the luminance.
      if options.component == None:
         replacementImage = replacementImage.convert("L")
      else:
         replacementImage = replacementImage.split()[options.component]
      
   import copy, Image, pyfits, os, sys
   from numpy import array, asarray, zeros

   # Read the input file:
   try:
      fitsImage, fitsHeader = pyfits.getdata(inputFilepath, 0, header=True)
   except IndexError:
      parser.error("The input file does not appear to be a FITS file.")

   # Check to make sure that the input file is 2D:
   if len(fitsImage.shape) != 2:
      parser.error("The input file must be a 2D FITS image.")

   if replacementImage != None:
      replacementImage = replacementImage.resize(fitsImage.shape[::-1])
      fitsImage = asarray(replacementImage)

   # Create a new 3D image, which has two copies of the input image as
   # the two slices into the third dimension:
   newImage = zeros((2,) + fitsImage.shape,
                    fitsImage.dtype)
   newImage[0, :, :] = fitsImage[:, :]
   newImage[1, :, :] = fitsImage[:, :]

   # Make a new header for the new image by copying the original header:
   newHeader = fitsHeader.copy()

   # Set the velocity axis to range from -c to +c:
   newHeader.update("crval3", options.velocityRange[0])
   newHeader.update("crpix3", 1)
   newHeader.update("cdelt3",
                    options.velocityRange[1] - options.velocityRange[0])
   newHeader.update("ctype3", "VELO-LSR")

   # Write out the new FITS file:
   if os.path.exists(outputFilepath): os.remove(outputFilepath)
   pyfits.writeto(outputFilepath, newImage, newHeader)

   # TODO: Add more robust error checking before os.remove().  E.g.,
   # check to make sure that it's not a directory.


#------------------------------------------------------------------------------
# parseCommandLine()
#------------------------------------------------------------------------------

def parseCommandLine():
   from optparse import OptionParser
   parser = OptionParser(usage=usage)

   parser.set_defaults(velocityRange=(-3e8, 3e8))

   parser.add_option("--replace-image",
                     dest="replacementImageFilepath",
                     help=("replace the FITS image with the image from "
                           "the specified file"),
                     metavar="IMAGE-FILE",
                     )
#    parser.add_option("--red-component",
#                      action="append_const", const=0, dest="colorComponent",
#                      help=("use the red component of the RGB replacement "
#                            "image")
#                      )
#    parser.add_option("--green-component",
#                      action="append_const", const=1, dest="colorComponent",
#                      help=("use the green component of the RGB replacement "
#                            "image")
#                      )
#    parser.add_option("--blue-component",
#                      action="append_const", const=2, dest="colorComponent",
#                      help=("use the blue component of the RGB replacement "
#                            "image")
#                      )

   componentChoices = ["red", "green", "blue"]

   parser.add_option("--component",
                     action="store",
                     choices=componentChoices,
                     dest="component",
                     )
   parser.add_option("--velocity-range",
                     type="float", nargs=2, dest="velocityRange",
                     )

   options, args = parser.parse_args()

   if len(args) != 2:
      parser.error("An input file and an output file are required.")

   if options.component:
      options.component = componentChoices.index(options.component)

#    if options.colorComponent:
#       if len(options.colorComponent) == 1:
#          options.colorComponent = options.colorComponent[0]
#       else:
#          parser.error("Only one color component is allowed")

   # inputFilepath = args[0]
   # outputFilepath = args[1]
   return parser


#------------------------------------------------------------------------------
# proc run_main()
#    raises any
#------------------------------------------------------------------------------

def run_main():
   import __main__
   try:
      if "--pdb" in sys.argv:
         sys.argv.remove("--pdb")
         import pdb
         pdb.run("main()")
      else: __main__.main()
   except SystemExit: raise
   except KeyboardInterrupt: stderr.write("\nTerminated with Control-C.\n")
   except:
      stderr.write("FATAL ERROR: An unhandled exception occurred!\n"
                   "A stack traceback follows:\n\n");
      raise


#-----------------------------------------------------------------------------
# Execute the program 
#-----------------------------------------------------------------------------
 
if __name__ == "__main__": run_main()
